POST MOTERM INTERPRETER

import json
from datetime import datetime

class POST_MORTEM:
    def __init__(self, routing_core_path):
        self.node_name = "POST_MORTEM"
        self.routing_core_path = routing_core_path

    def load_routing_core(self):
        with open(self.routing_core_path, "r") as f:
            return json.load(f)

    def save_routing_core(self, data):
        with open(self.routing_core_path, "w") as f:
            json.dump(data, f, indent=2)

    def interpret_signals(self):
        data = self.load_routing_core()
        node_data = data.get(self.node_name, {"signals": {}})
        signals = node_data.get("signals", {})

        if not signals:
            print(f"[{self.node_name}] No signals to post-mortem.")
            return

        for signal_name, packet in signals.items():
            lifecycle = packet.get("lifecycle", {})
            status = lifecycle.get("status")
            current_node = lifecycle.get("current_node")

            # Process only signals that have reached this node and are COMPLETE or ACTIVE (depending on flow)
            if current_node != self.node_name or status not in ("ACTIVE", "COMPLETE"):
                continue

            print(f"[{self.node_name}] Analyzing Signal: {signal_name}")

            sim_result = packet.get("simulation_result", {})
            final_exposure = packet.get("final_exposure", {})
            calibration = self.analyze_outcome(sim_result, final_exposure)

            # Update packet with post-mortem calibration feedback
            packet.setdefault("post_mortem_feedback", {})
            packet["post_mortem_feedback"].update(calibration)
            packet["post_mortem_timestamp"] = datetime.utcnow().isoformat() + "Z"

            # Optionally reset lifecycle or mark as archived
            lifecycle["status"] = "ARCHIVED"
            packet["lifecycle"] = lifecycle
            signals[signal_name] = packet

            print(f"[{self.node_name}] Calibration feedback: {calibration}")
            print(f"[{self.node_name}] Signal archived.")

        node_data["signals"] = signals
        data[self.node_name] = node_data
        self.save_routing_core(data)
        print(f"[{self.node_name}] Routing core updated.")

    def analyze_outcome(self, sim_result, final_exposure):
        feedback = {}

        # Example: Compare simulation outcome vs. exposure confidence
        sim_outcome = sim_result.get("simulated_outcome")
        exposure_category = final_exposure.get("category")

        if sim_outcome == "SUCCESS" and exposure_category == "HIGH_CONFIDENCE":
            feedback["calibration_adjustment"] = "maintain"
        elif sim_outcome == "FAILURE" and exposure_category == "HIGH_CONFIDENCE":
            feedback["calibration_adjustment"] = "reduce_risk"
        elif sim_outcome == "SUCCESS" and exposure_category == "LOW_CONFIDENCE":
            feedback["calibration_adjustment"] = "increase_risk"
        else:
            feedback["calibration_adjustment"] = "neutral"

        # Placeholder for more detailed calibration logic
        feedback["confidence_score"] = final_exposure.get("score", 0)

        return feedback

# === EXECUTION ===
if __name__ == "__main__":
    routing_core_path = "/mnt/data/SIGNAL_ROUTING_CORE_RETROFITTED.json"
    pm_node = POST_MORTEM(routing_core_path)
    pm_node.interpret_signals()